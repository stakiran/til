# C言語 勉強ノート

```
■mallocとfree
**ライブラリAでmallocした領域を利用者が直接解放してもいい？→ダメ
理由: メモリ空間が違うから

user
	#include <lib1.h>
	int *out;
	use_lib1_func(out);

lib1
	void use_lib1_func(int* out){
		…
		out = malloc(allocated_size);
		…
	}

lib1がメモリ空間1, userがメモリ空間2を使ってたら、
当然 lib1 で確保された out は解放できねえよね。

linuxではちゃんと解放できるが、
windowsでは無理みたい。

Q: じゃあどうすればいいの？
A: ライブラリ側で解放用関数を用意してやれ。

■strcpy, strncpy, strlen
**strcpy(dst, src)
srcサイズがdstサイズより大きい場合にbuffer overrunが出るから大問題！
使っちゃダメ。

**strncpy(dst, src, count)
srcの先頭からcount文字分をdstにコピー。

ただしdstにnull文字を自動的に付加することはない。
→dst初期化時にゼロクリアしておくのが定石みたい。

countはコピー元の文字数を指定するのが普通。

本関数は、コピー元のコピー数を指定することで、dstに書き込まれるサイズを最大countまでに抑えるというセキュリティを持つ。
countがdstのサイズを超えてる場合はバッファーオーバーフロー起こるので注意。

**strcpy_s(dst, numberofelements, src)
srcをdstにコピー, 末尾にnull文字も付加してくれる, numberofelementsにはdstのサイズを指定する
srcサイズがnumberofelementsを超えたらdstに0を書く(from http://msdn.microsoft.com/ja-jp/library/td1esda9.aspx)
linuxには実装されてない。

**strncpy_s
両者の合体版、一番安全ってわけか。
これもlinuxには実装されてない。

**strlen
null文字はカウントしない。

**コピーの要領
char src[ANY_SIZE];
strncpy(src, dst, sizeof(src)/sizeof(char)-1);
                  ~~~~~~~~~~~~~~~~~~~~~~~^
文字数を指定するため、
サイズ数から文字数を求めないといけない.

末尾の -1 は null 文字をコピーしないため。
こうすれば、srcの末尾1文字はコピーされない(srcをゼロクリアしてればnull終端を保証できる)。

■フォーマット指定子 *
printf("%*d",2,i);
	→フィールド幅 2

printf("%*d\n",i,i);
	→フィールド幅 i

■ポインタ読解練習
(int(*)(int,char)) 
intを返す関数(引数int,charを取る)へのポインタにキャスト。

実例を書くと…
nret = ((int(*)(PLCNS_MODULE_INFO, PLCNS_LCNSKEY_INFO, int*))glcnsctrlfunc[0].func[1][1])(pmod, plcnskey, plcnsnum);
⇒glcnsctrlfunc[0].func[1][1] を intを返す関数(引数として(PLCNS_MODULE_INFO, PLCNS_LCNSKEY_INFO, int*を取る)へのポインタ にキャストする。これは関数。これに引数pmod, plcnskey, plcnsnumを与えて実行する。実行結果がnretに入る。

----

char(*(*a())[])()
→charを返す関数へのポインタの配列へのポインタを返す関数a

char(*(*a())[])()
1    3 576  4  2

(1)左から右へ読む
(2)idenfifierはスキップ
(3)(…)はスキップし、まずは外側から読む。
   ただし()は関数なのでスキップせずに読む。

■"a" "b" → "ab"
文字列の間にホワイトスペース（改行含む）しか無い場合は連結される。"AAA" "BBB" → "AAAABBB" とみなされる。

■__FILE__など
__FILE__	ソースファイル名 (Windows はフルパス、Solaris はファイル名のみ)
__LINE__	行番号
__DATE__	コンパイル日付
__TIME__	コンパイル時間
__STDC__	ANSI規格対応ならば1、ANSI規格非対応ならば0

●C実践プログラミング読んでからのメモ
・C言語文法
・C言語の書き方
・メモリやコンパイラの仕組み
--------------------------------
・fgets( ) は、ファイルから、n-1 の文字を読み込み、文字列の末に NULL 文字（ '\0' ) を追加します。もし、途中で改行コード（ '\n' ) を読み込むと、改行コードの後に、 NULL 文字（ '\0' ) を書き込みます。

・フォーマット指定子 %(全体の桁数).(小数点の桁数)

・#ifdefで消したコードで、奇妙な構文エラーが発生する。ANSI Cでは#if、#ifdef、#ifndefによってコンパイルから除外されるテキストも「コンパイル前処理のトークンとして有効なものである」としているから。終端のないコメントや引用符があってはならないし、引用符で囲まれた部分に改行があってもダメ。自然言語のコメントや擬似コードは「公式の」コメントの区切り記号である/*と*/の間に書くこと。

・#define str(x) #x と書くと、文字列xを展開する。 char s[]="test"; printf("%s\n",str(s)); は s を出力するし、str("test") と書くと "test" (注:二重引用符も含む)を出力する。

・#define str(a,b) a##b と書くと、文字列aに文字列bを連結した文字列を展開する。char s[]="src", d=[]="dst"; printf("%s\n",str(s,d)); と書くと変数名 sd を出力しようとする挙動になる。

・char s[]="abc"; は {'a','b','c','\0'}; の別表現であり、必ず読み書きできる領域に保持されることが保証される。一方 char *s="abc"; は文字列 abc のメモリ上の位置を返すだけで、書き込み可能な領域を指しているとは限らない。

・switch-caseにおいて、defaultより下に書かれたcaseは実行される。

・コメントは /**/ で書くべき。元々C言語のコメントは /* */ だった。C++になって // がサポートされ、その後のCコンパイラにも搭載されるようになった。つまり古いCコンパイラは // に対応してない可能性あり。

・'#define'は自分以外の全て(前後のプリプロセッサ文含む)に対して単純な置換を行う。

・一つ以上の文を #define する場合は、そのコードを {} で囲む。

・構造体の圧縮で int a:1; メンバを定義した後、aに2以上の値を入れようとすると、1ビット以降の値は捨てられる。2を入れると0、3を入れると1、…という感じ。
	
・配列の要素数は sizeof(array)/sizeof(int) で求める

・マシン依存のコードは専用ファイルに書く。main.c と windows.c、main.c と linux.c みたいな。
・バイナリファイルのエイディアンはマシン依存。ファイルの先頭に識別番号を書いておき、プログラム内部で、あるエイディアン時の番号と、逆順のエイディアン時の番号の処理をそれぞれ書いておく。

・構造体でデータをまとめても、プログラマーが内部構造を知らないと操作できないようでは使いにくい。構造体は隠蔽した上で、特定の処理を行う関数を公開するのがベター。
・初期化処理をプログラマーに書かせるな。内部的に、もし初期化してなければ初期化するようなロジックを書いておけばいい。

(*curptr).data = value; と curptr->data = value; は等価。

freeで解放した後、当該ポインタにはNULLを入れること。free(ptr); ptr=NULL; こうすりゃ解放後のポインタを間違って使ってしまうことはない。

mallocの戻り値は調べること。ヒープから領域確保できなかった時はNULLが返る。

void func()は値を返さない関数、void *func()は総体ポインタを返す関数。

memsetは文字を1バイト毎にセットする。int a[10]; memset(a,1,sizeof(10)); と書いても 1 クリアはできない。sizeof(int) が2だとすると、1 は 0x0001 を表すが、この1バイト部分は 0x01 であり、memsetでは各バイトにこれを詰める。つまり a の各要素の値は 0x0101 になる。

memsetは文字をセットする標準ライブラリ関数。void *memset(void *buf, int ch, size_t n); ⇒ buf の先頭から n バイト分 ch をセットする。

最適化テク4。関数には呼び出し時のオーバヘッドがある。マクロはインラインで展開されるため、オーバヘッドが無い。

最適化テク3。配列インデックスの計算は、内部的には乗算で行われる。char m[XSIZE][YSIZE]; に対して m[x][y] を書くと実際は (*m + (x*YSIZE) + y) と変換される。この乗算を最適化するために、配列サイズを2の累乗にするといい。2の累乗の乗算は、内部的にはシフト演算で書かれる。シフト演算は乗算よりも高速。

最適化テク2。もっとも内側のループがもっとも複雑で、もっとも外側のループがもっとも単純になるようにする。内側のループは、外側のループ回数だけ実行される。内側のループ内処理のオーバヘッドが大きいとマズイよね。

最適化テク1。ローカル変数を register int i,j; のように宣言すると、高速なレジスタで処理させることができる。レジスタ数以上の register 宣言をしても構わない。多すぎる分はメインメモリに格納される。

最適化は無理に行うな。大抵のプログラムは十分な実行速度が得られるはず。最適化をするとコンパイルに時間かかるし、そのせいでコードに新たなエラーが生じる可能性もある。

告知的方法によるデバッグ。バグの発生した自分のコードを他人(いなければぬいぐるみでもいい)に口頭で説明すること。ある大学では、教員へ質問する前に「まずはここのぬいぐるみに説明してみよ」としていたりする。それほどに効果の高いやり方なのだろう。

printfはバッファリングを使うため、通過直後にエラーが起きても標準出力されるとは限らない。確実に表示させたくば fflush(stdout); を使うこと。

ループ中でのデバッグにて、カウンタが特定の値の時のみステップ実行したい場合。if(変数 == 特定の値) dummy = dummy; と書き、ブレークポイントを置けばいい。dummy = dummy; はブレークポイントを置くための便宜上のコード。こう書けば何の働きもしない。

デバッグコマンドのイメージ。runでプログラム起動, stop in 関数名 で指定関数の先頭行で停止。stop at linenumber で指定行にブレークポイント配置。step でステップ実行。print expression で式の値を表示…こんな感じ。対話型インタフェースみたい。

デバッグ方法。-Dxxxx と指定して色んなデバッグモードを再現する(たとえば-Dfz. これはfとzの二種類を指定している)場合。
1.char debug[128] = {0}; を定義
2.引数解析し、xxxxとして含まれる文字をインデックスとして、debugの値を1にする。例ではdebug['f'] と debug['z'] が1になる。
3.所定のデバッグ出力したいところに if(debug['f']) if(…)… などと書く。

char s[128] = {0}; と定義すると、残りの要素も全て0で埋められる。
 
コンパイラスイッチ -E プリプロセッサの出力を標準出力する。/ -Dsymbol[=value] コマンドラインからシンボル及びその値を定義する。/ -o filename 実行可能ファイル名を指定する。

UNIX	改行(0x0a、LineFeed)
MacOS	行頭復帰(0x0d、Carriage Return)
Windows	CR+LF

マジックナンバー。ファイルなどオブジェクト類の形式を識別するもの、フォーマット識別子のこと。バイナリファイルの先頭らへんに書いてある、固有のデータなんかはまさにこれ。UNIX系OSでは、先頭が 1F 8B のファイルはgzip圧縮されたデータとして扱われる。

バッファリング…データを、出力に十分な大きさになるか、フラッシュされるまで、バッファに溜める形式。読み出しや書き込みにはシステムコールを使うが、これは効率的ではない。バッファリングにて回数を抑えれば、R/Wの効率が上がる。ちなみに printf もバッファを使ってる。fflush(stdout) でバッファ内容を stdout に書き出せる。

アスキーファイル…メモ帳でちゃんと開けて解釈できるファイル。95の印字可能文字と33のコントロールコードで構成。高移植性。問題無く別のマシンに移せる。読み込み効率は悪い。アスキーファイルから数値を読み込む際は、sscanfのような変換ルーチンで文字データを処理しないといけないから。

バイナリファイル…メモ帳で開けて解釈できないファイル。読み込み時の変換は不要。アスキーファイルよりも大体サイズは小さい。移植性は無い。

引数解析は、argv[1][0] で '-' を見て, argv[1][1] に対してswitchを適用してスイッチ文字列を見て…という具合に実装するといい。

argv[0]はプログラム名から始まるよ。

main(int argc, char *argv[]) の引数の順番はアルファベット順と思えばいい。

ポインタの意義。
・「メモリと処理速度を倹約できる」こと。大きなサイズの一時変数を使う必要が無いし、それにデータを入れる手間も無い。
・データ構造を柔軟に(≒疎結合に)扱える。ポインタ同士で結んでやれば、各データがメモリ上のどこにあろうと関係が無い。

const char *a_ptr="hogehoge"; //ポインタ変数の参照先が定数になる
	a_prt=""fugafuga"; //ok 変数
	*a_prt='X'; //NG 定数

	/* 応用例:関数内でポインタの中身を変えさせたくない場合 */
	void print(const char *s) {
		puts(s);
		//この関数内では s[0]='\0'; などとは出来ない
	}

char *const a_ptr="hoge"; //ポインタ変数自体が定数になる
	a_prt="fugafuga"; //NG 定数
	*a_prt='X'; //OK char型

	a_ptrは配列と同じ扱いになる。
	a_ptr++; なんてことはできない。

ポインタ変数は名前で明示するべき。混乱するから。 hogehoge_ptr くらい極端でもいいくらい。

typedefが#defineを凌ぐ理由。typedef int group[10]; group totals; for(i=0; i<10; i++) totals[i]=0; こんなこともできる。

共用体。union unionname{…}valname; と書く。…内のデータ全てが一つの領域で共用される。…の内のメンバ1に値を入れた後、メンバ2に値を入れると、メンバ1を参照しても、取り出されるのはメンバ2に入れた値。

struct structname{…}valname; と typedef struct structname{…}anothername; は違う。前者は構造体定義と変数宣言、後者は構造体定義とその別名定義。

Cの右シフトは、ANSI標準では算術シフト(符号ビットで埋める)or論理シフト(0で埋める)のいずれかと指定されている。殆ど全てのコンパイラは算術シフト。

わざわざビット演算で書くような真似はしない。わかりにくい。シフトによる2^nの乗算除算も、普通の演算子で書くべき。そうすりゃ確かに高速にはなるが、最近のコンパイラは優秀なので速くしてくれる。

「#define」マクロのパラメータは必ず括弧で囲むこと。

標準ヘッダファイルは #include <hoge.h> と指定する。場所はUNIXなら/usr/include, Windowsではコンパイラのインストールディレクトリ。

「#include "hoge.h"」と書くと、その箇所に hoge.h の内容が挿入される。指定するのは単純なファイル名、相対パス、絶対パスどれでもいい。ただし絶対パスは、移植性が無いから使うな。

コメントアウトに #ifdef などを使うと、複数行コメントのネストに悩まずに済む。
	例：
	/*
	hogehoge
	/* 複数行コメント */ ←ここでコメントアウトが終わり。
	fugafuga
	*/ ←ここで構文エラーに

const vs #define
構文はすぐにチェックされる / 構文はマクロが使用されて(defineで置き換えられた部分を実行した時に)初めてチェックされる
構文はCに即する(=による代入など) / 構文は全て固有
スコープはCの通常の規則に従う / スコープは必ずグローバル

「#define DEFSTR replaced」と書くと、プリプロセッサがソース内の DEFSTR を replaced に置き換える。単純に、機械的に置き換える。

行末に \ を書くと、プリプロセッサの命令を次行に続けることができる。

構造化プログラミングとはトップダウンプログラミング。まずmain関数にて概要を作り、その後、各々の詳細の関数を作っていく。ボトムアッププログラミングもある。これは、最低限の関数を作り、テストし、その後、組み合わせていく。使ったことのない標準関数を使う場合、筆者はボトムを使うらしい。大切なのは、もっとも都合の良い方法を使うこと。

引数が空の関数をプロトタイプ宣言する場合、引数に void を指定する。何も指定しないのはレガシーで許されない。

関数定義時に、関数の型指定を省いた場合、デフォルトでintになる。紛らわしいので使うな。

ブロックの内側で定義したstatic変数は、グローバル変数と同じく、プログラム開始時に初期化される。

MS-DOS/Windowsではスタック領域(ローカル変数が割り当てられるメモリ領域)は65536バイト。大きい配列はグローバルにした方が無難。

forループでは一般的に 0 から始まり、終了させるためには < を使う。 1 から始まっていたり、 <= で終了していたりした場合、誤りを疑おう

コードリーディング。コードを印刷して、わからないことを書き込んでいく。それをコードに反映してく。コメント付けたり変数名変えたりするだろう。…これを繰り返して、コードをわかりやすく変えていく。

make。makeを実行したディレクトリに存在する makefile に従ってコンパイルを行う。

デバッグ用printfを使う場合、先頭に ## をつけて出力すると、デバッグ用である事が明確。

char型に空文字を入れたい場合は '\0' を入れる。 '' ではない。

式の中に代入文を混ぜるのはやめろ。常に簡潔に。見やすく。

数値入力は scanf の他に
fgets(line, sizeof(line), stdin); 
sscanf(line, "%d %d", &val1, &val2);
というやり方もある。scanfは行終端を扱うのが不十分なので、scanfに慣れないうちはこっちでいい。

前置/後置演算子は単独で使え。 a=(b++ * 5)+(b++ * 3); はどちらの括弧を先に計算するかで答えが違う。どちらが先かはコンパイラ依存。

int, long int, short intはデフォルトは符号付き。charはデフォルトは処理系依存。

char s[]={'a','b','c','\0'}; と char s[]="abc"; は同じ。

セグメンテーション違反。UNIXにはメモリプロテクションがあるが、Windowsには無いので、プログラムクラッシュ、システムクラッシュの恐れがある。

改行を取り除く汎用的アルゴリズム first[strlen(first)-1]='\0'

全ての変数にコメントを付けるのが、スタイルに関するルール。

_で始まる名前は、内部名やシステム名に確保されているので、利用には注意。

main関数のreturnによる戻り値は、値が大きいほど重大なエラー。

目標はわかりやすさ。技巧に走るな。
冗長でもわかりやすさを目指せ。

なるべく簡潔に。以下は経験則。
・関数の長さは3ページ以内に抑える
・ifの多重ネスト(のような複雑なロジック)はやめる
・式は1行、長くとも2行以内に抑える
これらを超えた場合、処理を関数作って細分化することを考える。

変数定義と同じ行にコメント書けば、Grepなどで探した時にわかりやすい。

emacsからコメントを簡単に挿入する。
.exrc
:abbr #b /***************************
:abbr #c ***************************/

先頭に書くコメント
標題…プログラム名、プログラムの概要
作成者…誰が作ったかわかれば、後々助言を得られる
目的…作成した理由は？それは何を実行するの？
使用方法

コンパイル
基本C言語に対する拡張機能を使用不可能にする。
	gcc -g -Wall -ansi -pedantic -ohello hello.c
```
