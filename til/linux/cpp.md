# C++ 勉強ノート

```
■アボートする
初期化処理と解放処理を両方呼んでるか確認して。

■string to integer
c++11 なら include <string> して
std::stoi(str)
これ。

■複数行文字列 ヒアドキュメント
**単に複数行に分けて書きたい場合

const char* str = "1"
                  "2"
                  "3";
puts(str); // 123

**改行文字を省きたい場合
	print_vec(Util::split(R"(HTTP/1.0 200 OK
Server: BaseHTTP/0.3 Python/2.6.5
Date: Tue, 18 Jul 2017 01:20:40 GMT
Content-Length: 4
Content-Type: text/plain)", '\n'));

わかりにくいけど

  R"(
  
  )"

これ。C++のみ。古いC++でもダメかも。

from http://marycore.jp/prog/c-lang/here-document-in-c-and-cpp/

■std::thread でメンバ関数をスレッド化するには？
c++. std::thread. メンバ関数をスレッド化するときは、std::thread th(method) はダメ。 std::thread(&MyClass::method, this) とやらないと。だってメンバ関数自体はインタスンス化されてなくて実体がないもの。

■std::thread スレッドで segfault セグメンテーション違反が起きる
$ g++ threadtest.cpp -std=c++0x -g -lpthread
                                   ^^^^^^^^^
                               これ忘れてませんか？

■newで確保した基本型をゼロクリアする
//_TCHAR *a = new _TCHAR[100];
_TCHAR *a = new _TCHAR[100]();

>http://d.hatena.ne.jp/DOSEI/20111013/p1>
規格では 5.3.4 の 5 で、
int * a = new int [100] ();
のように最後に括弧をつけることによって、 int 等の型でも value-initialized されることが規定されている。
<<

△Traits
わかったような、わからんような。。。

テンプレートクラスに、型ごとに異なる固定値を返したいメソッドを作りたい場合に使えるテクニック。普通にテンプレートメソッドを作るだけでは実現できない。なぜなら、テンプレートメソッド定義時に、返す値も定義しなければならないから。

	template<class T>
	class Hoge {
	pubilc:
	    T func1();
	};

	template<class T>
	T Hoge::func1(){
		return /* 何を返せばいい？ */
	}

intだったらこれ返して、doubleだったらこれ返す、みたいなことができない。テンプレート関数を特殊化しても、元のテンプレート関数の定義自体を定義できないので、ダメなんだ。しかしTraitsなら実現できる。

	//Traits
	template<class T>
	struct hoge_traits {};

	//Traitsを使うクラス
	template<class T>
	class Hoge {
	pubilc:
		typedef  hoge_traits<T>::traits_type traits_type
		traits_type func1() {return hoge_traits<T>::f();} //対象メソッド
		traits_type func2() {return hoge_traits<T>::g();} //対象メソッド
	};

	//型ごとに, 固定値を返すメソッドを作る
	// -返す型をTraits型に認識させるためのtypedefと
	// -具体的な値を返す関数
	template<>
	struct hoge_traits<char> {
		typedef  char  traits_type;
		static char f() {return 'A'};
		static char g() {return 'a'};
	};

	template<>
	struct hoge_traits<int> {
		typedef  int  traits_type;
		static int f() {return 90};
		static int g() {return 65};
	};

■アロケータ
メモリの割り当て/解放を行うためのオブジェクトのこと。主に標準コンテナのテンプレートで利用されている。std::vactor<int> v と書くのが普通だが、実は第二引数としてアロケータを指定できる。省略すれば普通のnew/deleteが使われる。普通のそれらは、処理速度よりも汎用性を犠牲にしているので遅い。もっと早いのを使いたい場合、自分でアロケータを作ればいいってこと。

■Functor
operator() だけを持ったクラスのこと。関数のように使うことができる。

関数と違う点
--内部状態を持てること
--コンストラクタに与える値によってバリエーションを動的に確保できること
--関数渡しを関数ポインタを使わずに実現できること

■テンプレートの特殊化
//テンプレート関数
template <class T>
class CSample{
public:
	CSample(){ std::cout << "class T version" << std::endl; }
};

//int型だけ特殊化
template <>
class CSample<int>{
public:
	CSample(){ std::cout << "int version" << std::endl; }
};

■for 文で error: too few template-parameter-lists が出る
たとえばこんなの
	for(int i=0, std::string::size_type idx=0; i<testWriteCount; i++, idx++){
		…
	}
	//error: too few template-parameter-lists

初期化部分がダメ。
int i=0, j=0 みたいに同じ型で列挙することしかできない。
どちらかをfor文の前に出すしかない。
→http://stackoverflow.com/questions/18200907/strange-too-few-template-parameter-lists-error

■C++ 'XXX' in namespace 'YYY' does not name a type.
XXXが見えてない。includeしてないとか、makeでビルド対象に含めてないとか。

■c++ expected constructor, destructor, or type conversion before ?? token
一例として。グローバル空間上でインスタンス作ったりメソッドを呼び出すことはできない。
→http://stackoverflow.com/questions/3356854/c-compiling-error-expected-constructor-destructor-or-type-conversion-befor

■C++ error: passing ???? as `this' argument of ???? discards qualifiers
引数の参照が const で指定されているのに const 指定していないメンバメソッドを呼び出した。

●C++ ムーブ系
定義はこんな感じ
	//#include <utility> //これが必要
	Stream::Stream(Stream&& other);
	Stream& operator =(Stream&& other);

ムーブ代入演算子では自己代入に備えること
	Stream& Stream::operator =(Stream&& other)
	{
		if (this != &other) {
			this->~Stream();
			new (this) Stream(std::move(other)); // placement new
		}
		return *this;
	}

デフォルトムーブコンストラクタは存在する。
→http://d.hatena.ne.jp/faith_and_brave/20100331/1270020213
基本的にはデフォルトのままでいい。
テストコード書いて動かなければ自前で足りない分を実装すればいいと思う。

■C++ テンプレートの特殊化部分で多重定義エラー
特殊化したテンプレートは、もはやテンプレートではなく関数定義であるため、ヘッダに書いてたら多重定義エラーになりえる。inline 化すれば回避可。
→http://stackoverflow.com/questions/5453361/c-template-specialization-linker-error-multiple-definitions

■c++ invalid use of imcomplete type
error: invalid use of incomplete type …
error: forward declaration of …

前方宣言したクラス型のインスタンスに対してメンバを呼び出しているとこうなってしまう。

□あとでまとめる
std::lock_guard<std::mutex> lock(mPopMutex); これ超便利。これ実行したら自動的にロックが取得されて、スコープ抜けたら自動的に解放してくれる。

ポインタの指す先のオブジェクトのデストラクタを呼ぶには、そのポインタをdeleteしないといけない。

streambuf。setpでbeginとendを更新。pptrで現在位置(3文字入力されてたら3だけ進んだ値が返る?), pbaseでbegin, epptrでendの位置を取得

列挙型。クラスAのpublic内に定義した列挙型enum E{a,b,c}をクラス外で使いたい場合、A::E enum1 = A::a のように書く。

does not name a type。列挙型を認識できてない。myenum NAME1::myfunc(…); → NAME1::myenum NAME1::myfunc(…); こんな感じで名前空間忘れないように。

名前空間の一部をdefineで置きかえらせるのはムリ。#define TARGET Util \n TARGET::create(); と書いても、Util::create() とはならずエラーになる。

std::fstream。ストリームにデータを流した時点で、それはファイルに書き込まれる。close時に一気に書き込むだなんてことはないみたい。→でも内部でバッファリングしてたら必ずそうとは限らないかも。

子クラス is an inaccessible base of 親クラス エラーの場合。publicで継承してるかどうかをチェック。省略したらprivateですよ。

クラス内クラス。単に内部に定義を書くだけ。publicで書けば外部からも使える。ただし クラス名::内部クラス名 という名前でないとアクセスできない。

▽---- ロベール勉強分 ----

■言語メモ
クラスの前方宣言…AがBを使い、BがAを使っている場合、普通に書くとコンパイルエラーになる。Aを先に書くと、その中で使ってるBが無いと怒られ、Bを先に書くと、その中で使ってるAが無いと怒られる。これを防ぐには、前方宣言を使う。たとえばこうする。
	class A;
	class B{…};
	class A{…};
Bを解釈する部分では、既に前方宣言されているのでAが何であるか(クラスなんだけど)わかる。エラーは出ない。ただしあくまでも宣言であって、宣言だけではインスタンス化はできないため、Bの中身に A obj; こんな記述があったらエラーになる。A* obj; ならエラーにならない。

・状態を保持するクラスに値が反映できないと思ったら、反映はできてたけどゲッターがおかしかった。int値を返すゲッターにreturnが書いてなかった。略したときに何返すかは処理系依存だよね確か。gccではゴミを返すみたいだが。

・基底クラスにvirtualでない単なる空メソッドを定義して、派生クラスでオーバライドしようとしても上手くいかないよ。「"派生クラスのインスタンスを指した"基底クラスへのポインタ」を使ってオーバライドしたメソッドを呼ぶ場合は。アップキャストされるから、常に空メソッドが呼ばれる。これを防ぐための機能がvirtualなんだよ。

・関数の後にconstを付けると「この関数はメンバ変数を変更することはないよ」とコンパイラに教えることが出来る。constな関数内でメンバ変数を変更しようとするとエラーになる。
こんな感じ → void PrintString() const;

・volatile は最適化を阻害する修飾子。コンパイラの最適化により変数定義自体が削除されることがあるが、その変数にvolatileを付けておけば、最適化を阻害できる。volatile性はconst_castで外せる。

・extern "C" 関数プロトタイプ; と書くと、その関数プロトタイプをCの内部表現として扱える。C++では関数はC++の内部表現で認識されるため、Cで書かれた関数は(Cの内部表現で認識されるため)認識できない。

・関数ポインタ
int* a(int, int); → int* を返す関数a
   1 32
int (*a)(int, int); → int を返す関数へのポインタa
  1  34 2

・メンバ関数ポインタ関連
int (MyClass::*a)() → int を返すMyClassメンバ関数へのポインタa
aに代入したい場合、 a = &MyClass::func; のように & を付ける決まり。
メンバ関数ポインタを使う時は (obj->*a)() とか (ref.*a)() で使える。
同メンバ関数bからaを使う場合、(this->*a)()と書く。this->a は省略できない」。
メンバ関数ポインタのサイズは固定ではない。環境依存。

・汎整数昇格。intより下の型 short, char, bool などが式中に出現した場合、intに暗黙的キャストされる。だから ~(unsigned char)0 と書いた時の 0 の型は int だったりする。

・スーパークラスでオーバーロードされた関数aがnコあったとする。サブクラスでaを一つでもオーバーライドすると、スーパー側の関数aは「nコ全部見えなくなってしまう」。これを解消するには、using Super::a; と書いて、スーパー側の関数aたちを取り込んでやればいい。

・using は現在のスコープに指定した名前空間を取り込むイメージ。おまじないとしてよく書く using namespace std; は std名前空間をグローバルスコープに取り込む。

・インタフェースを実現するには。仮想デストラクタ以外の全メンバ関数を純粋仮想関数にする。他のクラスはこれは仮想継承する。これなら、たとえ継承木が複雑であっても、インタフェースクラスはただ一つのみ共有されている上に、仮想関数もただ一つしかその実装が存在してはいけないため、継承した方で純粋に全ての純粋仮想関数を実装してやればいいってことになる。

・仮想継承。複数のクラスが、ある一つのクラスの資源を共有した形の継承のこと。class Sub : virtual public Super{…}; と書くと、SubはSuperを仮想継承できる。二つの異なるクラスがSubを継承した場合、Subが継承しているSuperのメンバ変数はその二つのクラス間で共有される。

・inline関数。inline修飾子を付けて関数定義するとそれはインライン関数になる。インライン関数を呼び出している部分には、その関数の処理が直接埋め込まれる。マクロと同じようなものだが、単なる置き換えとは違う。コンパイル中に処理を置き換えるのだ。
インラインは必ずしも実行されるわけではない。動作はコンパイルに依存する。どうしても行わせたい場合、コンパイラに強制的にインライン化を行うオプションが無いかどうかを調べるといい。
埋め込むためには関数の実装が見えないといけないため、インライン関数はヘッダファイル内で実装するべき。
メンバ関数もインライン化できる。inline修飾子を指定してもいいし、単にクラス定義内で実装してもいい。

・負の値を右シフトするとどうなるか(符号で埋める算術? 0を埋める論理?)は環境依存

・not演算子は~(チルダ)

・キャストの文法が面倒くさい理由。キャストは危険なものだから使いにくくしているのと、見た目にインパクトを与える(危険なことしてますよと一目でわかる)ため。また、キャスト箇所の検索も容易に行える。

・constキャスト。const int* p=15; に対し、const_cast<int*>(p); と書けば p のconstを外したキャストが行える。int*を受け取る関数にconst int*を渡したい場合(かつその関数を修正できない場合)などに使う。

・再解釈キャスト。int n=0x12345678; const char* p=reinterprit_cast<const char*>(&n); のように書く。この場合は int* から const char* にキャストしている。

・静的キャスト。いわゆる普通のキャスト。b = static_cast<unsigned char>(a); みたいな。これは b = (unsigned char)a; とも書ける。キャストできない場合、後者だと実行してみるまでエラーかどうかわからないが、前者だとコンパイルエラーになるので、前者が楽。

・フレンド。クラスAがフレンド関数orフレンドクラスを自身のメンバとして定義/宣言してやると、その関数を使えばorそのクラスから、Aのprivateメンバにアクセスできる。この関数はAのメンバ関数ではないことに注意。

・operator++()なら前置インクリメント、operator++(int)なら後置インクリメントをオーバーロードできる。int型の指定の有無で区別。

・operator-()なら単項演算子の-、operator-(hoge)なら二項演算子のオーバーロードを行える。引数の有無で区別されるようになっている。

・a() = 15; はおかしくはない。関数aが参照を返すのであれば、aが返した参照の参照先に15を入れるということになるのだから。

・例外2
オブジェクトをスローすることもできる。throw Exception("エラーですよ"); みたいな。捕捉するには catch(const Exception& err){…} と書く。
スローされた「派生クラスのオブジェクト」は、その派生クラスの基底クラスを捕捉するcatch文で捕捉できる。Exceptionクラスを継承したZeroDevisionExceptionクラスがあるとする。ZeroDevisionExceptionのオブジェクトをスローすると、それはcatch(const Exception& err){…} で捕捉される。
コンストラクタから外へ例外が投げられた場合、そのクラスのデストラクタは呼ばれない。コンストラクタの初期化子で例外が投げられた場合(MyClass obj("hoge"); ←これの実行で例外が発生したとか)、その例外は必ず再送出(同じ例外をスローする)される。

・例外
構文は try{…} catch(捕捉する型){…} と書く。catchは複数個書ける。
catch(...){…} と書くとあらゆる例外を捕捉できる。
例外をcatchで捕捉できなかった場合、標準ライブラリの terminate() が呼び出される。大抵はアボートするみたい。
スローには throw 投げたい例外の式; と書く。
スローされた場合, catchが見つかるまでプログラムを遡る。スローされた場所のcatchは辿らない。catchが見つかっても捕捉されない場合、遡りは続く。
関数に対してスローできる例外の型を指定できる。type function (arglist) throw (exception-type-list){…}; と書く。このような関数に指定以外の例外がスローされた場合、標準ライブラリの unexpected(); が実行される。

・vector。配列を便利に扱えるクラステンプレート。初期化はこんな感じ vector<int> v(5); 。v.resize(2); と書いて配列のサイズを増減するなど、便利なメソッドを多数持っている。

・テンプレートはいちいち実体を作る。template <class X> void func(X a){…}; と書いた時点では関数の実体は存在しない。func(10); という記述があれば、汎用データ型をintにしたfuncの実体が静的に作られる。つまり実行ファイルサイズは大きくなりやすい。静的に決めてるので動作は速い。

intが指定されればテンプレート引数をintにした関数なりクラスなりが生成される。実体

・テンプレートクラス。template <class X> class MyClass {…}; と書けば, クラスMyClass内で汎用データ型を扱える。テンプレートクラス利用時は MyClass<int> obj; のように型を指定してやる。この場合はintを指定したので、obj内部の汎用データ型はintとして扱われる。
クラステンプレートではデフォルト引数を書ける。template <class X = char> class MyClass {…}; と書けば、MyClass<> obj; のようにインスタンス化したときに、型がcharになる。<>は省略不可。

・テンプレート(汎用)関数。与えられた型になる汎用的な引数を作れる。template <class X> void func(X a){…} と書くと、aはintが与えられればintに、doubleが与えられればdoubleになる。このようなXは汎用データ型という。
template <class X, typename Y> void func(X a, Y b, X c){…} のように複数個指定も可。ただしfunc(1.0, "str", 0); などと書くと X は double なのか int なのかわからなくてエラーになる。func<int>(1.0, "str", 0);と書けば int にできる。
テンプレート引数内に指定する宣言子は{class|typename}。typenameは古いコンパイラはサポートしてない可能性アリ。
テンプレート関数をオーバーロードすれば、特定の型の場合のみ、テンプレート関数と異なる処理をさせることもできる。

・名前空間
namespace namespace-name{}; と書く。
グローバルな位置でしか定義できない。
ファイルAの名前空間はファイルBからもアクセスできる。
名前空間の中に名前空間を定義することもできる。
名前空間の分割定義も可能。 namespace myspace{int a1;} namespace myspace{int a2;} と書くと、myspaceはa1とa2を持つ。分割定義は複数のファイルに書ける。
無名名前空間の場合、ここにアクセスできるのは同一ファイルのみ。
名前空間には別名を付けることができる。namaspace fbb = foo:bar:baz; とか。

・マニピュレータ。printfのフォーマット指定子のようなことをストリーム上で行える。たとえば cout << swtw(5) << hex << uppercase; は, 標準出力時の最小幅を5、出力形式を大文字の16進数に設定している。マニピュレータの効果は、一度きりのものとずっと続くものがある。

・バイトオーダ
int n = 0x41424344; がメモリ上に格納される場合。
リトルエンディアン
	オフセット:   0  1  2  3
	各バイトの値: 41 42 43 44
ビッグエンディアン
	オフセット:   0  1  2  3
	各バイトの値: 44 43 42 41

・ファイルをバイナリで読み書きしたい場合は fstream file; file.write とか file.read とかを使う。

・c/c++では改行コードは \n として扱う。これをファイルに書き出す場合、そのファイルをテキストモードで扱っているのであれば、osに適したコードに変換する。winは\r\n, macは\r, linuxは\n。バイナリモードだとこの変換も行わない。

・ファイルを扱うには include <fstream> … fstream file; という感じ。

・stringstream(sstreamをincludeする)を使えば、stringstream sstr; sstr << "x:" << x << endl; cout << sstr.str(); なんてことが出来る。cin, coutの入力先/出力先が文字列になったバージョンを扱えるというわけ。

・日本語用の文字セットを扱いたい場合、stringクラスでは上手く扱えないことがある。Shift-JISの"表示"という文字列は、2バイト目の文字コードが \ と同じコードであるため、\ を検索するとヒットしてしまう。日本語用の文字セットを扱う用のライブラリが別途あると思うので、それを使いたいところ。

・stringクラスで文字列を扱いやすくなる。string str="hello"; str = "Hello"; str += ", World!\n"; みたいな。string型オブジェクトをchar*型の引数に渡したい場合は str.c_str() あるいは str.data()を使う。前者にはnullターミネータが付き、後者には付かない。

・仮想関数は仮想関数テーブルで実現される。これは「ある仮想関数を呼ぼうとしたとき、実際にはどの関数が呼ばれるのか」という対応を書いたテーブルのこと。各クラスはテーブルへのポインタを保持した隠しメンバ変数を持っている。

・サブクラスのコンストラクタからスーパクラスや自メンバ変数のコンストラクタを呼び出したい場合、MyClass : Super(引数){…} とか MyClass : myclassmember(引数){…} と書く。呼び出したいものが複数ある場合はカンマで区切ればいい。

・virtual。virtualな関数が呼ばれる際、それを呼んだオブジェクトの型から、それを継承したメソッドの有無を調べ、有るのならそれを呼ぶようにする…というイメージ。
名前の由来…これは単なる関数の挙動ではないから関数とはいえない。しかし普通に呼び出すだけで機能している。仮想的な関数と言えよう。的な。

・サブクラス定義時のアクセス指定子 class Sub : ACCESS Super{…}; は、サブクラスから見てスーパクラスのメンバがどう見えるかを指定する。publicと書くと、Superで定義されたアクセス指定子と同じ見え方。privateと書くと全てprivateに見える。「ここで定義したのと、スーパクラスで定義したのとで、より厳しい方を採用する」と覚えればわかりやすい。省略するとprivateになってしまうことにも注意。

・constメンバ関数は void print() const{…}; と書き、この関数内ではメンバ変数の値を変更できない(静的メンバ変数or mutable宣言されたメンバ変数は可能)。constメンバ関数から非constメンバ関数は呼べない。constオブジェクト(const MyClass constobj;)も非constメンバ関数を呼べない。

・operator=。オブジェクト代入時(MyClass a,b; … b=a; みたいな)に呼ばれる。自分で定義しなかったらデフォルトのoperator=が作られる。これは各メンバ変数にコピー元のメンバ変数を代入する。

・コピーコンストラクタ…オブジェクトの初期化時に呼ばれるコンストラクタ。仮引数生成時でも、内部的には一時オブジェクトを実引数で初期化しているため、呼ばれる。コピーコンストラクタを作らなかった場合、デフォルトのコピーコンストラクタが作られる。これは、全てのメンバ変数を、その型のコピーコンストラクタを使って複製するもの。ちなみに基本型にもコピーコンストラクタ型は存在する(引数の値で変数を初期化するだけ)。

・デフォルトコンストラクタ…引数無しでオブジェクトを定義した時に呼ばれるコンストラクタ。クラスを定義する際も引数無しで書いてやる。定義が無かったら勝手に作成される(基本型のメンバ変数を初期化せず、クラス型変数などはデフォルトコンストラクタを呼ぶ)。デフォルトコンストラクタ以外のコンストラクタを作った場合、デフォルトコンストラクタは勝手に創られない。

・delete NULLは問題無し。条件によってnewをするかどうかに対応できる。ただし古いコンパイラはこの仕様に対応していない可能性あり。

・deleteとdelete[]は使い分けること。delete pと書くだけでは、これはpが指す先のみを解放するのか、pは先頭アドレスを指しているから配列を丸々解放するのかがわからない。配列を解放することを明示するために[]を指定する仕様となっている。

・文字列リテラルはメモリ上のどこかに置かれた静的なデータで、プログラムが終わるまで破棄されることはない。

・リンケージ。ファイルを越えて利用できるかどうかをリンケージという。そのファイルの外部でも利用できるものは外部リンケージを持つという。
・extern宣言は、別の場所で定義された外部リンケージのグローバル変数を扱うという宣言。
・static無しの関数プロトタイプは、別の場所で書かれた外部リンケージの関数を扱うという宣言。(ただし既に同名同型の関数定義or関数プロトタイプがあれば、そのリンケージを引き継ぐ) 
・staticをつけると内部リンケージになる。
・ローカル変数はリンケージ無し。

・ローカル変数をstaticで定義すると静的な変数になる。一度のみ初期化されるようになり、関数を抜けても値が保持される。
・自動変数…静的でないローカル変数のこと。

・多次元配列のサイズ指定無しの初期化はこうする int n[][5] = {…}; 省略できるのは最初の部分のみ

・NULLポインタ…いかなる有効なアドレスとも等しくならないことが保証されているアドレス。文法上は 0 と表記する。値が 0 であるとは限らない。cout << (size_t)null; は -1 を返すことだってある(g++の場合)。

・const char* p → pの指す先は変更不可
  char* const p → pは変更不可
  const char* const p → pは変更不可、pの指す先も変更不可
  constの右側は変更できなくなる、と覚えればいい。

・const int unsigned hoge も int const unsigned hoge も同じ。constは型の一部なので順番を問わない。

・int n[SIZE];に対して &n[i] - &n[j] の値は i-j である。

・配列(の先頭アドレスを表す識別子)とポインタの違い。sizeofが返す値と、後から指す先を変更できるかどうか。

・配列のサイズに変数は指定できないが、const定数なら可能。ただしC++の仕様。Cでも新しいコンパイラならサポートしてることがある。

・参照にはリテラルを渡せない。int func(int& a){…}; func(10) はエラー。しかしconst参照だと可能。 int func(const int& a){…}; func(10); は通る。内部的には a は(いったん作られた)テンポラリオブジェクトへの参照になるみたい。

・参照とポインタの違い。参照は指し示す先を変更できないが、ポインタは出来る。参照は変数名で中身にアクセスできるが、ポインタは *(変数名) と書かねばならない。

・演算子オーバロードの理解の仕方。b=a → b.operator=(a) と解釈される。演算子オーバロード関数が引数二個で定義されてたら、b=a → operator=(b,a) と解釈される。

・アクセス指定子。public→どこからでもアクセス可能, protected→自クラス、派生クラスからアクセス可能, private→自クラスからアクセス可。クラス内のデフォルトはprivate。構造体はpublic。

・構造体も共用体も使える。メンバ関数を定義できるように拡張してある。公開設定は全メンバpublicとなる。C言語との互換性のための機能であるが、ついでならとメンバ関数を書けるという機能が追加された。

・explisitはコンストラクタに指定可能な修飾子。暗黙の型変換(MyClass obj="hello";)を無効にする。暗黙の型変換とは、MyClass obj("hello"); と同じ働きを代入演算子が持っているもので、コンパイラによって自動で追加される処理のこと。

ここから上はロベール
--------------------------------

・クラスメソッド、クラス変数は static 修飾子を付加して宣言。class MyClass{static int val = 0; static void method(){};}

・純粋仮想関数(いわゆる抽象メソッド)。virtual type function(arglist)=0; と書く。これを持つクラスは抽象クラスと呼び、オブジェクトを生成できない。抽象クラスを継承したクラスも抽象クラスだが、純粋仮想関数を再定義してやれば抽象ではなくなる。

・親クラスのポインタは子オブジェクトを指せる。子クラスは親クラスの機能を包含してるから。

・オーバーロードした各々のコンストラクタには、メンバを直接編集するように記述する。コンストラクタAの中でコンストラクタBを呼ぶのはダメ。Aを抜けた時に, Bで確保したインスタンスがデストラクトされてしまうから。

・動的メモリ割り当てはnewとdeleteを使う。newで配列を確保した場合, deleteではなくdelete []を使う。

・演算子のオーバーロード。インスタンス同士の演算を定義できる。obj1 += obj2 でobj1の各メンバの値にobj2の各メンバの値を足す、なんてことも可能。

■ロベール わからんとこ
p465 わからん。
p506-p510 コンストラクタ内のメンバ初期化子(member(arglist); の形での初期化)だと何故エラー復帰(コンストラクタ内での捕捉)が出来ないのか。member = hoge; はできるのに。memberが必ず初期化に失敗するから、というなら、member = hogeについても同様だろ。
p542 値に制限をかけてたら、これをそのまま参照を返す関数に置き換えることはできない…とあるがそれは何故？
p662 当然のことと言えるでしょう。なぜ？
p691 テンプレートの特殊化。文法がややこしくてスラスラ読めない。
p698- 関数ポインタ、メンバ関数ポインタあたり。文法ややこしくてスラスラ読めない。使い方すらイメージできてない。意義もピンと来てない。
```
